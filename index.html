<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShapeDraw Pro - Advanced Drawing Tool</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: manipulation;
        }

        :root {
            --dark-green: #0a2a1e;
            --medium-green: #1a3a2e;
            --light-green: #2a4a3e;
            --deep-orange: #ff6b35;
            --light-orange: #ff9e6d;
            --white: #f5f5f5;
            --gray: #a0a0a0;
            --canvas-bg: #ffffff;
        }

        body {
            background-color: var(--dark-green);
            color: var(--white);
            min-height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: var(--medium-green);
            padding: 0.8rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--deep-orange);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
            z-index: 100;
        }

        .back-button {
            background-color: var(--dark-green);
            color: var(--white);
            border: none;
            padding: 0.6rem 1.2rem;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 0.9rem;
        }

        .back-button:hover {
            background-color: var(--deep-orange);
            transform: translateY(-2px);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .logo i {
            color: var(--deep-orange);
            font-size: 1.5rem;
        }

        .logo h1 {
            font-size: 1.2rem;
            font-weight: 700;
            background: linear-gradient(to right, var(--deep-orange), var(--light-orange));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .canvas-container {
            flex: 1;
            background-color: var(--medium-green);
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .canvas-wrapper {
            background-color: var(--canvas-bg);
            border-radius: 8px;
            flex: 1;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
            width: 100%;
            height: 100%;
        }

        #drawingCanvas {
            display: block;
            cursor: crosshair;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Shape selection overlay */
        .shape-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .shape-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: var(--deep-orange);
            border: 2px solid var(--white);
            border-radius: 50%;
            pointer-events: all;
            cursor: move;
            transform: translate(-50%, -50%);
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .shape-bounding-box {
            position: absolute;
            border: 2px dashed var(--deep-orange);
            pointer-events: none;
            z-index: 15;
        }

        /* Mobile-optimized toolbar */
        .toolbar-container {
            background-color: var(--medium-green);
            padding: 0.8rem;
            border-top: 2px solid var(--light-green);
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            overflow-y: auto;
            max-height: 40vh;
            flex-shrink: 0;
        }

        .toolbar-section {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .section-title {
            font-size: 0.9rem;
            color: var(--light-orange);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding-bottom: 0.3rem;
            border-bottom: 1px solid var(--light-green);
        }

        .section-title i {
            font-size: 0.9rem;
        }

        .tool-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
        }

        .tool-button {
            background-color: var(--light-green);
            border: none;
            color: var(--white);
            padding: 0.6rem 0.8rem;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.2rem;
            transition: all 0.2s ease;
            min-width: 70px;
            flex: 1;
        }

        .tool-button:hover, .tool-button.active {
            background-color: var(--deep-orange);
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(255, 107, 53, 0.3);
        }

        .tool-button i {
            font-size: 1.1rem;
        }

        .tool-button span {
            font-size: 0.75rem;
            text-align: center;
        }

        .color-picker {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
        }

        .color-option {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .color-option:hover, .color-option.selected {
            border-color: var(--white);
            transform: scale(1.1);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
        }

        .brush-size-control {
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .brush-size-control input {
            flex: 1;
        }

        .brush-size-value {
            min-width: 50px;
            font-size: 0.8rem;
            color: var(--gray);
        }

        /* Suggestion panel - always visible */
        .suggestion-panel {
            background-color: var(--light-green);
            border-radius: 8px;
            padding: 0.8rem;
            margin-top: 0.8rem;
            display: none;
        }

        .suggestion-panel h3 {
            color: var(--light-orange);
            margin-bottom: 0.6rem;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .suggestion-options {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .suggestion-btn {
            background-color: var(--medium-green);
            border: 1px solid var(--deep-orange);
            color: var(--white);
            padding: 0.5rem 0.8rem;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.8rem;
            flex: 1;
            min-width: 120px;
        }

        .suggestion-btn:hover {
            background-color: var(--deep-orange);
        }

        /* Modal for shape library */
        .shape-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .shape-modal-content {
            background-color: var(--medium-green);
            padding: 1.5rem;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .shape-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--light-green);
            padding-bottom: 0.8rem;
        }

        .shape-modal-header h2 {
            color: var(--light-orange);
            font-size: 1.2rem;
        }

        .close-modal {
            background: none;
            border: none;
            color: var(--white);
            font-size: 1.5rem;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s;
        }

        .close-modal:hover {
            background-color: var(--deep-orange);
        }

        .shape-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 1rem;
        }

        .shape-modal-btn {
            background-color: var(--light-green);
            border: none;
            color: var(--white);
            padding: 1rem;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s ease;
        }

        .shape-modal-btn:hover {
            background-color: var(--deep-orange);
            transform: translateY(-3px);
        }

        .shape-modal-btn i {
            font-size: 1.5rem;
        }

        .shape-modal-btn span {
            font-size: 0.8rem;
        }

        /* Footer */
        .footer {
            background-color: var(--medium-green);
            padding: 0.8rem;
            text-align: center;
            border-top: 1px solid var(--light-green);
            font-size: 0.8rem;
            color: var(--gray);
            flex-shrink: 0;
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .main-container {
                flex-direction: row;
            }
            
            .canvas-container {
                flex: 3;
                padding: 1rem;
            }
            
            .toolbar-container {
                flex: 1;
                max-width: 300px;
                max-height: none;
                border-top: none;
                border-left: 2px solid var(--light-green);
                box-shadow: -4px 0 12px rgba(0, 0, 0, 0.2);
            }
            
            .header {
                padding: 1rem 1.5rem;
            }
            
            .logo h1 {
                font-size: 1.5rem;
            }
            
            .back-button {
                padding: 0.7rem 1.5rem;
                font-size: 1rem;
            }
        }

        @media (max-width: 767px) {
            .tool-row {
                justify-content: flex-start;
            }
            
            .tool-button {
                min-width: 60px;
                padding: 0.5rem 0.6rem;
            }
            
            .suggestion-btn {
                min-width: 100px;
            }
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--deep-orange);
            color: var(--white);
            padding: 0.8rem 1.2rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
            animation: slideIn 0.3s ease;
            max-width: 300px;
            font-size: 0.9rem;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Dragging cursor */
        .dragging {
            cursor: grabbing !important;
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="https://hencheng2.github.io/all/" target="_blank">
            <button class="back-button">
                <i class="fas fa-arrow-left"></i> Back
            </button>
        </a>
        <div class="logo">
            <i class="fas fa-draw-polygon"></i>
            <h1>ShapeDraw Pro</h1>
        </div>
        <div></div>
    </div>

    <div class="main-container">
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <canvas id="drawingCanvas"></canvas>
                <div class="shape-overlay" id="shapeOverlay"></div>
            </div>
            
            <!-- Suggestion panel - always visible -->
            <div class="suggestion-panel" id="suggestionPanel">
                <h3><i class="fas fa-lightbulb"></i> Shape Suggestions</h3>
                <div class="suggestion-options">
                    <button class="suggestion-btn" data-perfect-shape="circle">Perfect Circle</button>
                    <button class="suggestion-btn" data-perfect-shape="square">Perfect Square</button>
                    <button class="suggestion-btn" data-perfect-shape="triangle">Equilateral Triangle</button>
                    <button class="suggestion-btn" data-perfect-shape="line">Straight Line</button>
                    <button class="suggestion-btn" id="clearSuggestions">Clear</button>
                </div>
            </div>
        </div>

        <!-- Toolbar (mobile optimized, placed below canvas) -->
        <div class="toolbar-container">
            <!-- Drawing Tools -->
            <div class="toolbar-section">
                <div class="section-title">
                    <i class="fas fa-pencil-alt"></i> Drawing Tools
                </div>
                <div class="tool-row">
                    <button class="tool-button active" id="freehandTool">
                        <i class="fas fa-hand-paper"></i>
                        <span>Draw</span>
                    </button>
                    <button class="tool-button" id="selectTool">
                        <i class="fas fa-mouse-pointer"></i>
                        <span>Select</span>
                    </button>
                    <button class="tool-button" id="shapeLibraryBtn">
                        <i class="fas fa-shapes"></i>
                        <span>Shapes</span>
                    </button>
                </div>
            </div>

            <!-- Color Palette -->
            <div class="toolbar-section">
                <div class="section-title">
                    <i class="fas fa-palette"></i> Colors
                </div>
                <div class="color-picker">
                    <div class="color-option selected" style="background-color: #000000;" data-color="#000000"></div>
                    <div class="color-option" style="background-color: #ff6b35;" data-color="#ff6b35"></div>
                    <div class="color-option" style="background-color: #2a9d8f;" data-color="#2a9d8f"></div>
                    <div class="color-option" style="background-color: #e9c46a;" data-color="#e9c46a"></div>
                    <div class="color-option" style="background-color: #264653;" data-color="#264653"></div>
                    <div class="color-option" style="background-color: #e76f51;" data-color="#e76f51"></div>
                    <div class="color-option" style="background-color: #8ac926;" data-color="#8ac926"></div>
                    <div class="color-option" style="background-color: #1982c4;" data-color="#1982c4"></div>
                </div>
            </div>

            <!-- Brush Size -->
            <div class="toolbar-section">
                <div class="section-title">
                    <i class="fas fa-brush"></i> Brush Size
                </div>
                <div class="brush-size-control">
                    <input type="range" id="brushSize" min="1" max="30" value="5">
                    <div class="brush-size-value" id="brushSizeValue">5px</div>
                </div>
            </div>

            <!-- Edit Tools -->
            <div class="toolbar-section">
                <div class="section-title">
                    <i class="fas fa-edit"></i> Edit Tools
                </div>
                <div class="tool-row">
                    <button class="tool-button" id="undoBtn">
                        <i class="fas fa-undo"></i>
                        <span>Undo</span>
                    </button>
                    <button class="tool-button" id="redoBtn">
                        <i class="fas fa-redo"></i>
                        <span>Redo</span>
                    </button>
                    <button class="tool-button" id="mergeBtn">
                        <i class="fas fa-link"></i>
                        <span>Merge</span>
                    </button>
                    <button class="tool-button" id="deleteBtn">
                        <i class="fas fa-trash"></i>
                        <span>Delete</span>
                    </button>
                </div>
            </div>

            <!-- Export Tools -->
            <div class="toolbar-section">
                <div class="section-title">
                    <i class="fas fa-download"></i> Export
                </div>
                <div class="tool-row">
                    <button class="tool-button" id="downloadImage">
                        <i class="fas fa-file-image"></i>
                        <span>PNG</span>
                    </button>
                    <button class="tool-button" id="downloadPDF">
                        <i class="fas fa-file-pdf"></i>
                        <span>PDF</span>
                    </button>
                    <button class="tool-button" id="clearCanvas">
                        <i class="fas fa-broom"></i>
                        <span>Clear</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Shape Library Modal -->
    <div class="shape-modal" id="shapeModal">
        <div class="shape-modal-content">
            <div class="shape-modal-header">
                <h2><i class="fas fa-shapes"></i> Shape Library</h2>
                <button class="close-modal" id="closeModal">&times;</button>
            </div>
            <div class="shape-grid">
                <button class="shape-modal-btn" data-shape="rectangle">
                    <i class="far fa-square"></i>
                    <span>Rectangle</span>
                </button>
                <button class="shape-modal-btn" data-shape="circle">
                    <i class="far fa-circle"></i>
                    <span>Circle</span>
                </button>
                <button class="shape-modal-btn" data-shape="triangle">
                    <i class="fas fa-play"></i>
                    <span>Triangle</span>
                </button>
                <button class="shape-modal-btn" data-shape="line">
                    <i class="fas fa-minus"></i>
                    <span>Line</span>
                </button>
                <button class="shape-modal-btn" data-shape="star">
                    <i class="fas fa-star"></i>
                    <span>Star</span>
                </button>
                <button class="shape-modal-btn" data-shape="arrow">
                    <i class="fas fa-arrow-right"></i>
                    <span>Arrow</span>
                </button>
                <button class="shape-modal-btn" data-shape="heart">
                    <i class="fas fa-heart"></i>
                    <span>Heart</span>
                </button>
                <button class="shape-modal-btn" data-shape="hexagon">
                    <i class="fas fa-bezier-curve"></i>
                    <span>Hexagon</span>
                </button>
                <button class="shape-modal-btn" data-shape="pentagon">
                    <i class="fas fa-shield-alt"></i>
                    <span>Pentagon</span>
                </button>
                <button class="shape-modal-btn" data-shape="ellipse">
                    <i class="far fa-circle"></i>
                    <span>Ellipse</span>
                </button>
            </div>
        </div>
    </div>

    <div class="footer">
        <p>ShapeDraw Pro - Advanced Drawing & Shape Design Tool</p>
    </div>

    <!-- Toast notification -->
    <div class="toast" id="toast"></div>

    <script>
        // DOM Elements
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const shapeOverlay = document.getElementById('shapeOverlay');
        const suggestionPanel = document.getElementById('suggestionPanel');
        const toast = document.getElementById('toast');
        const shapeModal = document.getElementById('shapeModal');
        
        // Tool buttons
        const freehandTool = document.getElementById('freehandTool');
        const selectTool = document.getElementById('selectTool');
        const shapeLibraryBtn = document.getElementById('shapeLibraryBtn');
        
        // Color options
        const colorOptions = document.querySelectorAll('.color-option');
        
        // Brush size
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeValue = document.getElementById('brushSizeValue');
        
        // Edit buttons
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const mergeBtn = document.getElementById('mergeBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        
        // Export buttons
        const downloadImageBtn = document.getElementById('downloadImage');
        const downloadPDFBtn = document.getElementById('downloadPDF');
        const clearCanvasBtn = document.getElementById('clearCanvas');
        
        // Suggestion buttons
        const suggestionButtons = document.querySelectorAll('.suggestion-btn');
        const clearSuggestionsBtn = document.getElementById('clearSuggestions');
        
        // Shape modal buttons
        const closeModalBtn = document.getElementById('closeModal');
        const shapeModalButtons = document.querySelectorAll('.shape-modal-btn');
        
        // Application state
        let currentTool = 'freehand';
        let currentColor = '#000000';
        let currentBrushSize = 5;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let shapes = [];
        let selectedShapeIds = [];
        let history = [];
        let redoStack = [];
        let currentPath = [];
        let currentShapeType = null;
        let isCreatingShape = false;
        let shapeStartX = 0;
        let shapeStartY = 0;
        let isDraggingShape = false;
        let isDraggingSelection = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let draggedShapes = [];
        let shapeOffsetX = 0;
        let shapeOffsetY = 0;
        let shapeIdCounter = 0;
        let canvasRect = null;
        
        // Set canvas size
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            updateCanvasRect();
            redrawCanvas();
        }
        
        // Update canvas bounding rect for accurate coordinates
        function updateCanvasRect() {
            canvasRect = canvas.getBoundingClientRect();
        }
        
        // Initialize the app
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('scroll', updateCanvasRect);
            window.addEventListener('resize', updateCanvasRect);
            
            // Set initial canvas background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add event listeners
            setupEventListeners();
            
            // Show welcome message
            showToast('Welcome to ShapeDraw Pro! Draw or add shapes from the library.');
        }
        
        // Set up all event listeners
        function setupEventListeners() {
            // Tool selection
            freehandTool.addEventListener('click', () => setTool('freehand'));
            selectTool.addEventListener('click', () => setTool('select'));
            shapeLibraryBtn.addEventListener('click', () => shapeModal.style.display = 'flex');
            
            // Color selection
            colorOptions.forEach(option => {
                option.addEventListener('click', () => {
                    colorOptions.forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    currentColor = option.getAttribute('data-color');
                });
            });
            
            // Brush size
            brushSizeInput.addEventListener('input', () => {
                currentBrushSize = parseInt(brushSizeInput.value);
                brushSizeValue.textContent = `${currentBrushSize}px`;
            });
            
            // Shape selection from modal
            shapeModalButtons.forEach(button => {
                button.addEventListener('click', () => {
                    currentShapeType = button.getAttribute('data-shape');
                    shapeModal.style.display = 'none';
                    setTool('shape');
                    showToast(`Click and drag to draw a ${currentShapeType}`);
                });
            });
            
            // Modal close
            closeModalBtn.addEventListener('click', () => shapeModal.style.display = 'none');
            shapeModal.addEventListener('click', (e) => {
                if (e.target === shapeModal) {
                    shapeModal.style.display = 'none';
                }
            });
            
            // Edit tools
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            mergeBtn.addEventListener('click', mergeShapes);
            deleteBtn.addEventListener('click', deleteSelected);
            
            // Export tools
            downloadImageBtn.addEventListener('click', downloadAsImage);
            downloadPDFBtn.addEventListener('click', downloadAsPDF);
            clearCanvasBtn.addEventListener('click', clearCanvas);
            
            // Suggestion buttons
            suggestionButtons.forEach(button => {
                if (button.id !== 'clearSuggestions') {
                    button.addEventListener('click', () => {
                        applyPerfectShape(button.getAttribute('data-perfect-shape'));
                    });
                }
            });
            
            clearSuggestionsBtn.addEventListener('click', () => {
                suggestionPanel.style.display = 'none';
            });
            
            // Canvas events - FIXED: Proper coordinate tracking
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);
            
            // Touch events for mobile - FIXED
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('touchcancel', handleTouchEnd);
            
            // Prevent context menu on canvas
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        // Set the current tool
        function setTool(tool) {
            currentTool = tool;
            
            // Update active button
            freehandTool.classList.toggle('active', tool === 'freehand');
            selectTool.classList.toggle('active', tool === 'select');
            
            // Update cursor
            if (tool === 'select') {
                canvas.style.cursor = 'default';
            } else {
                canvas.style.cursor = 'crosshair';
            }
            
            // Clear selection when switching tools
            if (tool !== 'select') {
                selectedShapeIds = [];
                updateShapeOverlay();
            }
        }
        
        // Get accurate canvas coordinates - FIXED VERSION
        function getCanvasCoordinates(e) {
            if (!canvasRect) updateCanvasRect();
            
            let clientX, clientY;
            
            if (e.type.includes('touch')) {
                // For touch events
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                    e.preventDefault(); // Prevent scrolling
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    // For touchend events
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    return { x: 0, y: 0 };
                }
            } else {
                // For mouse events
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            // Calculate position relative to canvas
            const x = clientX - canvasRect.left;
            const y = clientY - canvasRect.top;
            
            // Scale coordinates to match canvas internal size
            const scaleX = canvas.width / canvasRect.width;
            const scaleY = canvas.height / canvasRect.height;
            
            return {
                x: x * scaleX,
                y: y * scaleY
            };
        }
        
        // Start drawing
        function startDrawing(e) {
            // Update canvas rect for accurate coordinates
            updateCanvasRect();
            
            const { x, y } = getCanvasCoordinates(e);
            
            if (currentTool === 'freehand') {
                isDrawing = true;
                [lastX, lastY] = [x, y];
                currentPath = [{x, y}];
                
                // Start drawing immediately
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y);
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentBrushSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
            } 
            else if (currentTool === 'shape' && currentShapeType) {
                isCreatingShape = true;
                shapeStartX = x;
                shapeStartY = y;
            }
            else if (currentTool === 'select') {
                // Check if clicked on a shape
                const clickedShapeId = getShapeAtPosition(x, y);
                
                if (clickedShapeId !== null) {
                    // Start dragging the shape(s)
                    isDraggingSelection = true;
                    dragStartX = x;
                    dragStartY = y;
                    
                    // Get the clicked shape
                    const clickedShape = getShapeById(clickedShapeId);
                    
                    // Select shape if not already selected
                    if (!selectedShapeIds.includes(clickedShapeId)) {
                        if (e.shiftKey || e.ctrlKey || e.metaKey) {
                            // Multi-select
                            selectedShapeIds.push(clickedShapeId);
                        } else {
                            // Single select
                            selectedShapeIds = [clickedShapeId];
                        }
                        updateShapeOverlay();
                    }
                    
                    // Store all selected shapes for dragging
                    draggedShapes = selectedShapeIds.map(id => getShapeById(id));
                    
                    // Store offset from click point to shape position
                    shapeOffsetX = x - clickedShape.x;
                    shapeOffsetY = y - clickedShape.y;
                    
                    // Change cursor
                    canvas.classList.add('dragging');
                } else {
                    // Clicked on empty space, clear selection unless shift/ctrl is held
                    if (!e.shiftKey && !e.ctrlKey && !e.metaKey) {
                        selectedShapeIds = [];
                        updateShapeOverlay();
                    }
                }
            }
        }
        
        // Draw on canvas
        function draw(e) {
            // Update canvas rect for accurate coordinates
            updateCanvasRect();
            
            const { x, y } = getCanvasCoordinates(e);
            
            if (isDraggingSelection && draggedShapes.length > 0) {
                // Calculate drag distance
                const dx = x - dragStartX;
                const dy = y - dragStartY;
                
                // Update drag start position
                dragStartX = x;
                dragStartY = y;
                
                // Move all dragged shapes
                draggedShapes.forEach(shape => {
                    if (shape) {
                        shape.x += dx;
                        shape.y += dy;
                    }
                });
                
                // Redraw canvas and update overlay
                redrawCanvas();
                updateShapeOverlay();
                return;
            }
            
            if (currentTool === 'freehand' && isDrawing) {
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentBrushSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
                
                [lastX, lastY] = [x, y];
                currentPath.push({x, y});
            }
            else if (currentTool === 'shape' && isCreatingShape) {
                // Redraw canvas with temporary shape
                redrawCanvas();
                
                // Draw the temporary shape
                ctx.save();
                drawShape(ctx, shapeStartX, shapeStartY, x, y, currentShapeType, currentColor, currentBrushSize, true);
                ctx.restore();
            }
        }
        
        // Stop drawing
        function stopDrawing(e) {
            if (currentTool === 'freehand' && isDrawing) {
                isDrawing = false;
                
                // Save the freehand drawing as a shape
                if (currentPath.length > 1) {
                    saveToHistory();
                    
                    const bounds = getPathBounds(currentPath);
                    const shapeId = ++shapeIdCounter;
                    
                    shapes.push({
                        type: 'freehand',
                        path: [...currentPath],
                        color: currentColor,
                        brushSize: currentBrushSize,
                        x: bounds.x,
                        y: bounds.y,
                        width: bounds.width,
                        height: bounds.height,
                        id: shapeId,
                        isSelected: false
                    });
                    
                    // Show suggestion panel for freehand drawings
                    const aspectRatio = bounds.width / bounds.height;
                    if (aspectRatio > 0.7 && aspectRatio < 1.3 && bounds.width > 30 && bounds.height > 30) {
                        suggestionPanel.style.display = 'block';
                    }
                }
                
                currentPath = [];
                redrawCanvas();
            }
            else if (currentTool === 'shape' && isCreatingShape) {
                const { x, y } = getCanvasCoordinates(e);
                isCreatingShape = false;
                
                // Only create shape if it has reasonable size
                if (Math.abs(x - shapeStartX) > 5 || Math.abs(y - shapeStartY) > 5) {
                    saveToHistory();
                    
                    const shapeId = ++shapeIdCounter;
                    
                    // Create the shape object
                    shapes.push({
                        type: currentShapeType,
                        x: Math.min(shapeStartX, x),
                        y: Math.min(shapeStartY, y),
                        width: Math.abs(x - shapeStartX),
                        height: Math.abs(y - shapeStartY),
                        color: currentColor,
                        brushSize: currentBrushSize,
                        id: shapeId,
                        isSelected: false
                    });
                    
                    redrawCanvas();
                }
            }
            else if (isDraggingSelection) {
                isDraggingSelection = false;
                draggedShapes = [];
                saveToHistory();
                canvas.classList.remove('dragging');
            }
        }
        
        // Touch event handlers for mobile - FIXED
        function handleTouchStart(e) {
            updateCanvasRect();
            startDrawing(e);
        }
        
        function handleTouchMove(e) {
            draw(e);
        }
        
        function handleTouchEnd(e) {
            stopDrawing(e);
        }
        
        // Draw a shape on canvas
        function drawShape(context, x1, y1, x2, y2, type, color, brushSize, isPreview = false) {
            const x = Math.min(x1, x2);
            const y = Math.min(y1, y2);
            const width = Math.abs(x2 - x1);
            const height = Math.abs(y2 - y1);
            
            context.strokeStyle = color;
            context.lineWidth = brushSize;
            context.fillStyle = color + (isPreview ? '40' : '20');
            context.lineJoin = 'round';
            context.lineCap = 'round';
            
            switch(type) {
                case 'rectangle':
                    context.fillRect(x, y, width, height);
                    context.strokeRect(x, y, width, height);
                    break;
                case 'circle':
                    const centerX = x + width / 2;
                    const centerY = y + height / 2;
                    const radius = Math.min(width, height) / 2;
                    context.beginPath();
                    context.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    context.fill();
                    context.stroke();
                    break;
                case 'ellipse':
                    const ellCenterX = x + width / 2;
                    const ellCenterY = y + height / 2;
                    const ellRadiusX = width / 2;
                    const ellRadiusY = height / 2;
                    context.beginPath();
                    context.ellipse(ellCenterX, ellCenterY, ellRadiusX, ellRadiusY, 0, 0, Math.PI * 2);
                    context.fill();
                    context.stroke();
                    break;
                case 'triangle':
                    context.beginPath();
                    context.moveTo(x + width / 2, y);
                    context.lineTo(x, y + height);
                    context.lineTo(x + width, y + height);
                    context.closePath();
                    context.fill();
                    context.stroke();
                    break;
                case 'line':
                    context.beginPath();
                    context.moveTo(x1, y1);
                    context.lineTo(x2, y2);
                    context.stroke();
                    break;
                case 'star':
                    drawStar(context, x + width / 2, y + height / 2, Math.min(width, height) / 2, 5, color, brushSize, isPreview);
                    break;
                case 'arrow':
                    drawArrow(context, x1, y1, x2, y2, color, brushSize, isPreview);
                    break;
                case 'heart':
                    drawHeart(context, x + width / 2, y + height / 2, Math.min(width, height) / 2, color, brushSize, isPreview);
                    break;
                case 'hexagon':
                    drawPolygon(context, x + width / 2, y + height / 2, Math.min(width, height) / 2, 6, color, brushSize, isPreview);
                    break;
                case 'pentagon':
                    drawPolygon(context, x + width / 2, y + height / 2, Math.min(width, height) / 2, 5, color, brushSize, isPreview);
                    break;
            }
        }
        
        // Draw a star shape
        function drawStar(context, cx, cy, radius, points, color, brushSize, isPreview) {
            const outerRadius = radius;
            const innerRadius = radius / 2;
            
            context.beginPath();
            
            for (let i = 0; i < points * 2; i++) {
                const angle = (Math.PI / points) * i;
                const r = i % 2 === 0 ? outerRadius : innerRadius;
                const x = cx + Math.cos(angle) * r;
                const y = cy + Math.sin(angle) * r;
                
                if (i === 0) {
                    context.moveTo(x, y);
                } else {
                    context.lineTo(x, y);
                }
            }
            
            context.closePath();
            context.fillStyle = color + (isPreview ? '40' : '20');
            context.fill();
            context.stroke();
        }
        
        // Draw a heart shape
        function drawHeart(context, cx, cy, size, color, brushSize, isPreview) {
            context.beginPath();
            const topCurveHeight = size * 0.3;
            
            context.moveTo(cx, cy + size/3);
            // Left top curve
            context.bezierCurveTo(
                cx, cy, 
                cx - size/2, cy, 
                cx - size/2, cy + size/3
            );
            // Left bottom curve
            context.bezierCurveTo(
                cx - size/2, cy + size/2, 
                cx, cy + size, 
                cx, cy + size
            );
            // Right bottom curve
            context.bezierCurveTo(
                cx, cy + size, 
                cx + size/2, cy + size/2, 
                cx + size/2, cy + size/3
            );
            // Right top curve
            context.bezierCurveTo(
                cx + size/2, cy, 
                cx, cy, 
                cx, cy + size/3
            );
            
            context.closePath();
            context.fillStyle = color + (isPreview ? '40' : '20');
            context.fill();
            context.stroke();
        }
        
        // Draw a polygon
        function drawPolygon(context, cx, cy, radius, sides, color, brushSize, isPreview) {
            context.beginPath();
            
            for (let i = 0; i < sides; i++) {
                const angle = (Math.PI * 2 * i) / sides - Math.PI / 2;
                const x = cx + Math.cos(angle) * radius;
                const y = cy + Math.sin(angle) * radius;
                
                if (i === 0) {
                    context.moveTo(x, y);
                } else {
                    context.lineTo(x, y);
                }
            }
            
            context.closePath();
            context.fillStyle = color + (isPreview ? '40' : '20');
            context.fill();
            context.stroke();
        }
        
        // Draw an arrow
        function drawArrow(context, fromX, fromY, toX, toY, color, brushSize, isPreview) {
            const headLength = 15;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            // Draw the line
            context.beginPath();
            context.moveTo(fromX, fromY);
            context.lineTo(toX, toY);
            context.strokeStyle = color;
            context.lineWidth = brushSize;
            context.stroke();
            
            // Draw the arrowhead
            context.beginPath();
            context.moveTo(toX, toY);
            context.lineTo(
                toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6)
            );
            context.lineTo(
                toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6)
            );
            context.closePath();
            context.fillStyle = color;
            context.fill();
        }
        
        // Redraw the entire canvas
        function redrawCanvas() {
            // Clear canvas with white background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw all shapes
            shapes.forEach(shape => {
                ctx.save();
                
                // Draw the shape
                if (shape.type === 'freehand') {
                    ctx.strokeStyle = shape.color;
                    ctx.lineWidth = shape.brushSize;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    ctx.beginPath();
                    if (shape.path.length > 0) {
                        ctx.moveTo(shape.path[0].x, shape.path[0].y);
                        for (let i = 1; i < shape.path.length; i++) {
                            ctx.lineTo(shape.path[i].x, shape.path[i].y);
                        }
                    }
                    ctx.stroke();
                } else {
                    drawShape(
                        ctx, 
                        shape.x, 
                        shape.y, 
                        shape.x + shape.width, 
                        shape.y + shape.height, 
                        shape.type, 
                        shape.color, 
                        shape.brushSize,
                        false
                    );
                }
                
                ctx.restore();
            });
        }
        
        // Update the shape overlay (selection handles)
        function updateShapeOverlay() {
            // Clear overlay
            shapeOverlay.innerHTML = '';
            
            // Add bounding boxes and handles for selected shapes
            selectedShapeIds.forEach(id => {
                const shape = getShapeById(id);
                if (!shape) return;
                
                // Create bounding box
                const box = document.createElement('div');
                box.className = 'shape-bounding-box';
                box.style.left = `${shape.x}px`;
                box.style.top = `${shape.y}px`;
                box.style.width = `${shape.width}px`;
                box.style.height = `${shape.height}px`;
                shapeOverlay.appendChild(box);
                
                // Create resize handles (only for non-freehand shapes)
                if (shape.type !== 'freehand') {
                    // Top-left handle
                    createHandle(shape.x, shape.y, 'nwse-resize', shape.id, 'tl');
                    
                    // Top-right handle
                    createHandle(shape.x + shape.width, shape.y, 'nesw-resize', shape.id, 'tr');
                    
                    // Bottom-left handle
                    createHandle(shape.x, shape.y + shape.height, 'nesw-resize', shape.id, 'bl');
                    
                    // Bottom-right handle
                    createHandle(shape.x + shape.width, shape.y + shape.height, 'nwse-resize', shape.id, 'br');
                }
            });
        }
        
        // Create a resize handle
        function createHandle(x, y, cursor, shapeId, type) {
            const handle = document.createElement('div');
            handle.className = 'shape-handle';
            handle.style.left = `${x}px`;
            handle.style.top = `${y}px`;
            handle.style.cursor = cursor;
            handle.dataset.shapeId = shapeId;
            handle.dataset.handleType = type;
            
            shapeOverlay.appendChild(handle);
        }
        
        // Get shape at position
        function getShapeAtPosition(x, y) {
            // Check shapes in reverse order (top to bottom)
            for (let i = shapes.length - 1; i >= 0; i--) {
                const shape = shapes[i];
                
                if (shape.type === 'freehand') {
                    // For freehand shapes, check if point is near the path
                    if (isPointNearFreehand(x, y, shape)) {
                        return shape.id;
                    }
                } else {
                    // For regular shapes, check bounding box
                    if (x >= shape.x && x <= shape.x + shape.width && 
                        y >= shape.y && y <= shape.y + shape.height) {
                        return shape.id;
                    }
                }
            }
            
            return null;
        }
        
        // Check if point is near a freehand path
        function isPointNearFreehand(x, y, shape) {
            const threshold = shape.brushSize + 5; // pixels
            for (let i = 0; i < shape.path.length; i++) {
                const point = shape.path[i];
                const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                if (distance <= threshold) {
                    return true;
                }
            }
            return false;
        }
        
        // Get shape by ID
        function getShapeById(id) {
            return shapes.find(shape => shape.id === id);
        }
        
        // Get bounds of a path
        function getPathBounds(path) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            path.forEach(point => {
                minX = Math.min(minX, point.x);
                minY = Math.min(minY, point.y);
                maxX = Math.max(maxX, point.x);
                maxY = Math.max(maxY, point.y);
            });
            
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
        
        // Apply perfect shape
        function applyPerfectShape(shapeType) {
            if (shapes.length === 0) return;
            
            const lastShapeIndex = shapes.length - 1;
            const lastShape = shapes[lastShapeIndex];
            
            if (lastShape.type !== 'freehand') return;
            
            saveToHistory();
            
            // Replace the freehand shape with a perfect shape
            shapes[lastShapeIndex] = {
                type: shapeType,
                x: lastShape.x,
                y: lastShape.y,
                width: lastShape.width,
                height: lastShape.height,
                color: lastShape.color,
                brushSize: lastShape.brushSize,
                id: lastShape.id,
                isSelected: false
            };
            
            redrawCanvas();
            showToast(`Applied perfect ${shapeType} to your drawing.`);
        }
        
        // Merge selected shapes
        function mergeShapes() {
            if (selectedShapeIds.length < 2) {
                showToast('Select at least 2 shapes to merge.');
                return;
            }
            
            saveToHistory();
            
            // Get the selected shapes
            const selectedShapes = selectedShapeIds.map(id => getShapeById(id)).filter(s => s);
            
            // Calculate merged bounds
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            selectedShapes.forEach(shape => {
                minX = Math.min(minX, shape.x);
                minY = Math.min(minY, shape.y);
                maxX = Math.max(maxX, shape.x + shape.width);
                maxY = Math.max(maxY, shape.y + shape.height);
            });
            
            // Create a new merged shape (as a group)
            const mergedShape = {
                type: 'group',
                shapes: [...selectedShapes],
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY,
                color: currentColor,
                brushSize: currentBrushSize,
                id: ++shapeIdCounter,
                isSelected: false
            };
            
            // Remove the original shapes
            selectedShapeIds.forEach(id => {
                const index = shapes.findIndex(shape => shape.id === id);
                if (index !== -1) {
                    shapes.splice(index, 1);
                }
            });
            
            // Add the merged shape
            shapes.push(mergedShape);
            
            // Clear selection
            selectedShapeIds = [];
            updateShapeOverlay();
            
            redrawCanvas();
            showToast(`Merged ${selectedShapes.length} shapes into a group.`);
        }
        
        // Delete selected shapes
        function deleteSelected() {
            if (selectedShapeIds.length === 0) {
                showToast('Select shapes to delete.');
                return;
            }
            
            saveToHistory();
            
            // Remove shapes
            selectedShapeIds.forEach(id => {
                const index = shapes.findIndex(shape => shape.id === id);
                if (index !== -1) {
                    shapes.splice(index, 1);
                }
            });
            
            selectedShapeIds = [];
            updateShapeOverlay();
            redrawCanvas();
            showToast('Deleted selected shapes.');
        }
        
        // Undo last action
        function undo() {
            if (history.length === 0) return;
            
            const lastState = history.pop();
            redoStack.push(JSON.parse(JSON.stringify(shapes)));
            shapes = lastState;
            redrawCanvas();
            updateShapeOverlay();
            showToast('Undo completed.');
        }
        
        // Redo last undone action
        function redo() {
            if (redoStack.length === 0) return;
            
            const lastUndoneState = redoStack.pop();
            history.push(JSON.parse(JSON.stringify(shapes)));
            shapes = lastUndoneState;
            redrawCanvas();
            updateShapeOverlay();
            showToast('Redo completed.');
        }
        
        // Save current state to history
        function saveToHistory() {
            history.push(JSON.parse(JSON.stringify(shapes)));
            redoStack = [];
            
            // Limit history size
            if (history.length > 20) {
                history.shift();
            }
        }
        
        // Clear canvas
        function clearCanvas() {
            if (shapes.length === 0) {
                showToast('Canvas is already empty.');
                return;
            }
            
            if (confirm('Clear the entire canvas? This cannot be undone.')) {
                saveToHistory();
                shapes = [];
                selectedShapeIds = [];
                redrawCanvas();
                updateShapeOverlay();
                showToast('Canvas cleared.');
            }
        }
        
        // Download as image
        function downloadAsImage() {
            // Create a temporary canvas with white background
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            // Fill with white background
            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Draw all shapes
            shapes.forEach(shape => {
                if (shape.type === 'freehand') {
                    tempCtx.strokeStyle = shape.color;
                    tempCtx.lineWidth = shape.brushSize;
                    tempCtx.lineCap = 'round';
                    tempCtx.lineJoin = 'round';
                    
                    tempCtx.beginPath();
                    if (shape.path.length > 0) {
                        tempCtx.moveTo(shape.path[0].x, shape.path[0].y);
                        for (let i = 1; i < shape.path.length; i++) {
                            tempCtx.lineTo(shape.path[i].x, shape.path[i].y);
                        }
                    }
                    tempCtx.stroke();
                } else {
                    // For regular shapes, draw them
                    const x2 = shape.x + shape.width;
                    const y2 = shape.y + shape.height;
                    
                    tempCtx.strokeStyle = shape.color;
                    tempCtx.lineWidth = shape.brushSize;
                    tempCtx.fillStyle = shape.color + '20';
                    tempCtx.lineJoin = 'round';
                    tempCtx.lineCap = 'round';
                    
                    switch(shape.type) {
                        case 'rectangle':
                            tempCtx.fillRect(shape.x, shape.y, shape.width, shape.height);
                            tempCtx.strokeRect(shape.x, shape.y, shape.width, shape.height);
                            break;
                        case 'circle':
                            const centerX = shape.x + shape.width / 2;
                            const centerY = shape.y + shape.height / 2;
                            const radius = Math.min(shape.width, shape.height) / 2;
                            tempCtx.beginPath();
                            tempCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                            tempCtx.fill();
                            tempCtx.stroke();
                            break;
                        // Add other shape types as needed
                    }
                }
            });
            
            const link = document.createElement('a');
            link.download = 'shapedraw-drawing.png';
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
            showToast('Image downloaded successfully!');
        }
        
        // Download as PDF
        function downloadAsPDF() {
            showToast('PDF export requires additional libraries. PNG download is available.');
            
            // In a real implementation, you would use a library like jsPDF
            // For now, we'll just show a toast message
        }
        
        // Show toast notification
        function showToast(message) {
            toast.textContent = message;
            toast.style.display = 'block';
            
            setTimeout(() => {
                toast.style.display = 'none';
            }, 3000);
        }
        
        // Initialize the application
        init();
    </script>
</body>
</html>
